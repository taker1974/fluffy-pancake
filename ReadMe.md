**introduction-to-sql-corrections:**

Исправления по рекомендациям от проверяющих:

Григорий Каляшов
10.01.25 21:02
Привет!

По работе все хорошо:

 - верно созданы эндпоинты для получения студентов и факультетов;
 - правильно написаны необходимые sql-запросы;
 - верно настроена связь между студентом и факультетом и реализованы необходимые эндпоинты по шагу 4.

Но:

 - вместо использования NullPointerException лучше создать свой класс исключения, а @ExceptionHandler можно вешать на разные классы исключений, тогда не придется писать условие с instanceof

    @ExceptionHandler(StudentNotFoundException.class)
    public ResponseEntity<ErrorData> handleStudentNotFoundException(StudentNotFoundException e) {
        ....
    }

    @ExceptionHandler(RuntimeException.class)
    public ResponseEntity<ErrorData> handleException(RuntimeException e) {
       ....
    }

Условия задания выполнены, работу засчитываю.
Успехов в дальнейшем обучении :)

---
Да, полностью согласен. Гигачат подтверждает:

В сервисах Java не рекомендуется использовать NullPointerException (NPE) по нескольким причинам:

1. Непрозрачность: NullPointerException не предоставляет никакой информации о том, какой объект был null и почему это произошло. Это может затруднить отладку и понимание проблемы.

2. Непредсказуемость: NullPointerException может возникнуть в любом месте кода, где происходит обращение к null-объекту. Это может привести к непредсказуемому поведению программы и трудноуловимым ошибкам.

3. Неправильное использование: NullPointerException часто используется как способ обработки ошибок, что является плохой практикой. Вместо этого, лучше использовать проверки на null и выбрасывать более информативные исключения.

4. Производительность: Обработка NullPointerException может быть дорогостоящей с точки зрения производительности, особенно если она происходит в цикле или в критическом пути выполнения программы.

Вместо использования NullPointerException, рекомендуется использовать проверки на null и выбрасывать более информативные исключения, которые помогут понять, что пошло не так.

---
Dto типа ErrorResponse, Гигачат:

Расположение классов DTO в иерархии проекта может зависеть от структуры вашего проекта и ваших предпочтений, но обычно они располагаются в отдельном пакете или модуле.

Если у вас есть слоистая архитектура (например, слой представления, слой сервисов, слой доступа к данным), то DTO обычно располагаются в слое сервисов или в отдельном слое передачи данных.

Вот пример структуры проекта с DTO:

com.example.project<br>
├── dto<br>
│   ├── UserDTO.java<br>
│   └── ...<br>
├── service<br>
│   ├── UserService.java<br>
│   └── ...<br>
├── repository<br>
│   ├── UserRepository.java<br>
│   └── ...<br>
└── ...<br>

В этом примере классы DTO располагаются в пакете `dto`, а классы сервисов и репозиториев - в пакетах `service` и `repository` соответственно.

Если у вас есть модульная архитектура, то DTO могут располагаться в отдельном модуле, который может быть использован другими модулями.

Важно помнить, что главное - это сохранить логическую структуру проекта и сделать его понятным и удобным для работы.

---
